<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><title>Autonomous Navigation - MuSHR: The UW Open Racecar Project</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=https://mushr.io/favicon.png><link rel=stylesheet href=/css/style.min.d6c2c7df4a2b74e47c295ee499fec19eb99dfe63f90766a829090f557e381bdc.css></head><body class='page page-tutorials-single'><div id=main-menu-mobile class=main-menu-mobile><ul><li class=menu-item-quickstart><a href=/tutorials/quickstart/><span>Quickstart</span></a></li><li class=menu-item-about><a href=/about/><span>About</span></a></li><li class=menu-item-docs><a href=https://github.com/prl-mushr/mushr#component-documentation><span>Docs</span></a></li><li class=menu-item-hardware><a href=/hardware/><span>Hardware</span></a></li><li class="menu-item-tutorials active"><a href=/tutorials/><span>Tutorials</span></a></li><li class=menu-item-press><a href=/press/><span>Press</span></a></li><li class=menu-item-team><a href=https://personalrobotics.cs.washington.edu/people/><span>Team</span></a></li><li class=menu-item-forum><a href=https://github.com/prl-mushr/mushr/discussions><span>Community Forum</span></a></li><li class=menu-item-contact><a href=/contact/><span>Contact</span></a></li></ul></div><div class=wrapper><div class=header><div class=container><div class=logo><a href=https://mushr.io/><img alt="Figurit Homepage" src=https://mushr.io/imgs/mushr-logo.svg></a></div><div class=logo-mobile><a href=https://mushr.io/><img alt="Figurit Homepage" src=https://mushr.io/imgs/mushr-logo.svg></a></div><div id=main-menu class=main-menu><ul><li class=menu-item-quickstart><a href=/tutorials/quickstart/><span>Quickstart</span></a></li><li class=menu-item-about><a href=/about/><span>About</span></a></li><li class=menu-item-docs><a href=https://github.com/prl-mushr/mushr#component-documentation><span>Docs</span></a></li><li class=menu-item-hardware><a href=/hardware/><span>Hardware</span></a></li><li class="menu-item-tutorials active"><a href=/tutorials/><span>Tutorials</span></a></li><li class=menu-item-press><a href=/press/><span>Press</span></a></li><li class=menu-item-team><a href=https://personalrobotics.cs.washington.edu/people/><span>Team</span></a></li><li class=menu-item-forum><a href=https://github.com/prl-mushr/mushr/discussions><span>Community Forum</span></a></li><li class=menu-item-contact><a href=/contact/><span>Contact</span></a></li></ul></div><button id=toggle-main-menu-mobile class="hamburger hamburger--slider" role=presentation aria-label="mobile menu trigger">
<span class=hamburger-box><span class=hamburger-inner></span></span></button></div></div><div class="container pb-6 pt-6 pt-md-10 pb-md-10"><div class="row justify-content-start"><div class="col-12 col-md-8"><div class="tutorial tutorial-single"><h1 class=title>Autonomous Navigation</h1><div class=content><p>Initialize and operate MuSHRs out-of-the-box autonomous navigation stack!</p><h4 class=properties>Intermediate Tutorial | Expected duration is 30 minutes</h4><h2>By: <a href=https://www.linkedin.com/in/markusschiffer/>Markus Schiffer</a> & 
    <a href=https://www.sidharthtalia.com/>Sidharth Talia</a><p><figure><video muted autoplay loop>
<source src=/tutorials/autonomous-navigation/auto.mp4 type=video/mp4></video></figure><br></p><h2 id=introduction>Introduction</h2><h3 id=goal>Goal</h3><p>This tutorial will teach you how to set up and operate MuSHR&rsquo;s baseline autonomous navigation stack. By the end of the tutorial, the car should be able to autonomously navigate around known obstacles on a known map.</p><h3 id=prerequisites>Prerequisites</h3><ul><li>If in sim, complete the <a href=https://mushr.io/tutorials/noetic_quickstart/>quickstart tutorial</a></li><li>If on real car, complete the <a href=https://mushr.io/tutorials/noetic_first_steps/>noetic robot software setup tutorial</a></li></ul><h4 id=note-on-dependecies>Note on dependecies:</h4><p>This tutorial is designed for the python3 ROS noetic image. It assumes that this accounts for any dependencies needed.</p><p>If you are operating in simulation and use the particle filter for localization, we do not recommend testing with the <code>sandbox.yaml</code> default map as the localization system struggles in an open environment (all positions look the same!). See the <a href=https://mushr.io/tutorials/noetic_quickstart/>quickstart tutorial</a> for how to change maps.</p><h2 id=navigation-stack-overview>Navigation Stack Overview</h2><p>At the highest level MuSHR&rsquo;s navigation stack consists of three principal components:</p><ol><li><p><strong>Receding Horizon Controller (RHC) Node:</strong> This node is responsible for motion planning and generating controls(steering, speed) for the car. The implementation shipped with the car uses a Model Predictive Controller (MPC) to generate control signals which are sent to the car&rsquo;s motor controller (VESC).</p></li><li><p><strong>Localization Node:</strong> In order for the controller to know where it is, and therefore also whether it is in the proximity of known obstacles in the map, it must know its location. Solving this problem is called &ldquo;localization&rdquo;. The Localization Node is implemented using a method called Particle Filtering which relies primarily on a data stream from the laser scanner.</p></li><li><p><strong>Planner Node</strong> This node generates a plan that the RHC controller will follow. The planner does not consider dynamic obstacles when constructing its plan; rather it uses a static map of the environment. It chains the car&rsquo;s motion primitives together into a plan, using a search algorithm (such as A*).</p></li></ol><p>This tutorial does not cover either the theory or the inner workings of the Model Predictive Control, Particle Filter, and A* search.</p><h2 id=installing-the-navigation-stack>Installing the Navigation Stack</h2><p><strong>Note</strong>: The docker container may already have the required packages pre-installed. These instructions have been provided in case you need to reinstall the packages from scratch (for example, you need to reset environment).</p><p>If you&rsquo;re setting up autonomous navigation on the MuSHR car (not just the sim), ensure the on-board computer (either a jetson nano or a jetson Xavier NX) is connected to the internet. You may have to connect your system to a monitor to do this as the default setting is for the on-board computer to act as a hotspot. Once you&rsquo;ve connected your system to the internet, you&rsquo;ll need to find the IP address of the car,</p><p>On the car&rsquo;s computer, run the following command:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ifconfig</span></span></code></pre></div></p><p>Find the <code>inet addr</code> line:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>wlp0s20f3 Link encap:Ethernet  HWaddr ABCDCEGFJOSDHOHSOGHOS  
</span></span><span class=line><span class=cl>          inet addr:192.168.43.254 --&gt; This is the RACECAR_IP</span></span></code></pre></div></p><p>From your desktop/laptop, SSH into your racecar.<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ssh robot@RACECAR_IP</span></span></code></pre></div></p><p>If you prefer, these steps can also be done with a mouse, keyboard, and monitor plugged into the MuSHR car, using the Ubuntu UI.</p><p>Download the packages for the RHC, Particle Filter and Global Planner (note that the Noetic stack is not yet the default):</p><p><strong>Note</strong>: You also need to download all dependencies for the <a href=https://github.com/prl-mushr/mushr_rhc><code>mushr_rhc</code></a> .<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Go to your catkin workspace</span>
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> ~/catkin_ws/src
</span></span><span class=line><span class=cl><span class=c1># Clone the RHC node</span>
</span></span><span class=line><span class=cl>$ git clone git@github.com:prl-mushr/mushr_rhc.git
</span></span><span class=line><span class=cl><span class=c1># Checkout the noetic branch</span>
</span></span><span class=line><span class=cl>$ git checkout noetic_rhc_replace
</span></span><span class=line><span class=cl><span class=c1># Clone the Particle Filter node</span>
</span></span><span class=line><span class=cl>$ git clone git@github.com:prl-mushr/mushr_pf.git
</span></span><span class=line><span class=cl><span class=c1># Checkout the noetic branch</span>
</span></span><span class=line><span class=cl>$ git checkout noetic
</span></span><span class=line><span class=cl><span class=c1># Install [SBPL](http://sbpl.net) for the global planner</span>
</span></span><span class=line><span class=cl>$ sudo apt-get install ros-noetic-sbpl
</span></span><span class=line><span class=cl><span class=c1># Install the Global Planner (this is for Jetson Xavier NX or sim use)</span>
</span></span><span class=line><span class=cl>$ git clone git@github.com:prl-mushr/mushr_gp.git
</span></span><span class=line><span class=cl><span class=c1># If you&#39;re using the jetson nano, use the mushr_gprm planner:</span>
</span></span><span class=line><span class=cl>$ git clone git@github.com:prl-mushr/mushr_gprm.git
</span></span><span class=line><span class=cl><span class=c1># which has our custom networkx implementation</span>
</span></span><span class=line><span class=cl>$ pip uninstall networkx
</span></span><span class=line><span class=cl>$ pip install git+https://github.com/brianhou/networkx.git
</span></span><span class=line><span class=cl><span class=c1># Make</span>
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> ~/catkin_ws <span class=o>&amp;&amp;</span> catkin_make</span></span></code></pre></div></p><h3 id=important>IMPORTANT</h3><p>The reason why there are two planners (mushr_gp and mushr_gprm) is because mushr_gp is too resource intensive to run on the jetson nano 4GB variant. However, if the desktop/laptop computer remains connected and in range of the MuSHR car, you can run mushr_gp on the computer instead since there will be a single ROS master. If you need the planner to run on the jetson nano, we recommend using the mushr_gprm package. For the Jetson Xavier NX or when running on the sim exclusively, mushr_gp will work. Both repositories contain ROS packages that reproduce the desired functionality. You need only concern yourself with each package&rsquo;s launch files to use them effectively. You can find the launch files in each package&rsquo;s <code>launch</code> directory.</p><h2 id=starting-the-navigation-stack>Starting the navigation stack</h2><p>We will now launch the navigation stack on the robot. To learn more about effective operation and experimentation strategies with the MuSHR car, visit the <a href>workflow tutorial</a>. We suggest using <a href=https://hackernoon.com/a-gentle-introduction-to-tmux-8d784c404340><code>tmux</code></a> to manage multiple ROSlaunch sessions. tmux allows operating multiple tabs within the same ssh connection.</p><h3 id=starting-the-docker-image>Starting the docker image:</h3><p><strong>Note:</strong> If you&rsquo;re operating on the robot, you&rsquo;ll need to SSH into it. If you&rsquo;re operating in sim, you can just open a new terminal and skip the tmux related commands.</p><p>As we are running the entire system from docker, the first thing to do is to start the docker image. To do this, execute:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ mushr_noetic</span></span></code></pre></div><p>Once you&rsquo;ve ssh&rsquo;d into your robot and started the docker image, activate <code>tmux</code>:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ tmux</span></span></code></pre></div></p><p>Then, to create two vertical panes, type <code>ctrl+b</code> (<code>ctrl</code> and <code>b</code>) then <code>%</code> (or alternatively <code>"</code> to split horizontally). You can use <code>ctrl+b</code> then your left and right arrow keys to switch between windows. We will need four panes for this tutorial on the real car, and three on the simulator.</p><p><strong>Note:</strong> If the map you are using is very large map (>100x100 meters)&ndash;size inclusive of the unknown region&ndash;then the controller will be stuck sampling points. Save yourself the headache and shrink/crop your map before you begin. (<a href=https://www.gimp.org/>Gimp</a> is a good tool for this job.</p><p>You can navigate tmux panes by typing <code>ctrl+b</code> then <code>[arrow key]</code> (or simply make new terminal tabs and avoid tmux altogether if you&rsquo;re doing this in sim).</p><p>If you&rsquo;re using seperate tabs instead of tmux, make sure they are all connected to the running docker image. You can do this with the following steps:
First, we need the docker&rsquo;s <code>CONTAINER ID</code>. Execute the following command:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ docker ps</span></span></code></pre></div></p><p>Expected output:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>CONTAINER ID   IMAGE                COMMAND   CREATED          STATUS          PORTS     NAMES
</span></span><span class=line><span class=cl>189781eba455   mushr/mushr:x86_64   <span class=s2>&#34;bash&#34;</span>    <span class=m>52</span> minutes ago   Up <span class=m>52</span> minutes             install_mushr_noetic_run_a85227ee45d5</span></span></code></pre></div></p><p>the <code>CONTAINER ID</code> can now be used to enter the docker from a new tab with the following command:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker <span class=nb>exec</span> -it CONTAINER_ID bash    </span></span></code></pre></div>where you&rsquo;ll replace <code>CONTAINER_ID</code> with your container ID.</p><h2 id=starting-the-system>Starting the system</h2><p>Any autonomy related task will require data from sensors and some way of sending the control commands to the hardware. In addition, manual control may also be required for safety reasons, or for the purposes of generating a map of an area via manual operation of the car. All these basic features are handled by a single launch file called <code>teleop.launch</code></p><h3 id=on-the-mushr-car>On the MuSHR car:</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_base teleop.launch</span></span></code></pre></div><p>Now launch the <code>map_server</code>:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Make sure mushr/mushr_base/mushr_base/mushr_base/maps has your map </span>
</span></span><span class=line><span class=cl><span class=c1># and mushr_base/launch/includes/map_server.launch is set to your map</span>
</span></span><span class=line><span class=cl>$ roslaunch mushr_base map_server.launch</span></span></code></pre></div></p><p>Now, we will launch the localization node:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_pf real.launch</span></span></code></pre></div>Wait for the node to initialize:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ Vesc callback called <span class=k>for</span> first time....
</span></span><span class=line><span class=cl>$ Initialization complete</span></span></code></pre></div><p>Then activate the RHC node,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_rhc real.launch</span></span></code></pre></div><p>Wait for the code to initialize<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>MPC
</span></span><span class=line><span class=cl>Control Node Initialized</span></span></code></pre></div></p><p>Finally, launch the global planner node (use the planner appropriate for your system):</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_gp real.launch</span></span></code></pre></div>Or alternatively<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_gprm real.launch</span></span></code></pre></div></p><p>Wait for it to initialize:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309032.479218601<span class=o>]</span>: Planner ROS node constructed. Need to initialize state
</span></span><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309032.644907822<span class=o>]</span>: Resizing the map
</span></span><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309033.229219658<span class=o>]</span>: Environment initialized
</span></span><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309033.261994212<span class=o>]</span>: Updated costmap</span></span></code></pre></div></p><h3 id=in-simulation>In simulation:</h3><p>When running in simulation, the steps are more or less the same as those for the real car, with the difference being that</p><ol><li>We use the mushr_sim package to start the <code>teleop.launch</code></li><li>Absence of the particle filter (not necessary in simulation)</li><li>Differences in the names of the launch files (instead of <code>real.launch</code> we use <code>sim.launch</code>)</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_sim teleop.launch</span></span></code></pre></div><p>Then activate the RHC node,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_rhc sim.launch</span></span></code></pre></div><p>Wait for the code to initialize<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>MPC
</span></span><span class=line><span class=cl>Control Node Initialized</span></span></code></pre></div></p><p>Finally, launch the global planner node (use the planner appropriate for your system):</p><p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_gp sim.launch</span></span></code></pre></div>Or alternatively<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ roslaunch mushr_gprm sim.launch</span></span></code></pre></div></p><p>Wait for it to initialize:<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309032.479218601<span class=o>]</span>: Planner ROS node constructed. Need to initialize state
</span></span><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309032.644907822<span class=o>]</span>: Resizing the map
</span></span><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309033.229219658<span class=o>]</span>: Environment initialized
</span></span><span class=line><span class=cl><span class=o>[</span> INFO<span class=o>]</span> <span class=o>[</span>1658309033.261994212<span class=o>]</span>: Updated costmap</span></span></code></pre></div></p><h2 id=running-the-navigation-stack>Running the navigation stack</h2><p>To operate the navigation stack, we will use foxglove to send pose targets to the vehicle. The <a href=https://mushr.io/tutorials/quickstart/>quickstart tutorial</a> tutorial goes over how to use foxglove with the MuSHR stack. When operating in the real world, the pose estimate of the car may be incorrect. You can correct this by providing the particle filter with the correct pose estimate using the <code>Set Pose Estimate</code> button on the bottom right of the foxglove window and then using the button to publish clicked points.</p><p><strong>Note</strong>: When publishing a pose, the pose will correspond to the pose at the tip of the arrow and not the base of the arrow. Set the pose accordingly.</p><p><strong>Note</strong>: Sometimes Foxglove might not show certain ROS topics (for example, the path published by the global planner) because these topics are hidden initially. To unhide them, press the gear icon in the 3D window, and then in the topics dropdown, press the closed eye button (or open eye button if you want to rehide them).</p><p><figure><img src=/tutorials/autonomous-navigation/set_pose_estimate.png width=800></figure><br></p><p>In <strong>simulation</strong>, you may want to set the starting pose of the car at a certain point. To do this, click the <code>Set Pose</code> button on the bottom right of the foxglove window and use &ldquo;Publish point&rdquo; to publish a point or &ldquo;Publish Pose&rdquo; to publish a pose for the car.:</p><p><figure><img src=/tutorials/autonomous-navigation/set_pose.png width=800></figure><br></p><p>To set a pose target, click on &lsquo;Set Goal&rsquo; button on the bottom right of the foxglove window and use &ldquo;Publish pose&rdquo; to publish a goal pose for the car:</p><p><figure><img src=/tutorials/autonomous-navigation/set_goal.png width=800></figure><br></p><p>The following video demonstrates the process of starting and running the stack in sim. In the real world, the difference would be the launch files being executed, and possibly the requirement to set the initial pose estimate.</p><p><figure><video muted autoplay loop>
<source src=/tutorials/autonomous-navigation/final_vid_stack.mp4 type=video/mp4></video></figure><br></p><p>That&rsquo;s it, now you have basic autonomous navigation!</p></div></div></div></div></div><div class="strip strip-primary-gradient-top-bottom"><div class="container pt-3 pb-3 pt-md-6 pb-md-3 px-2"><div class="row justify-content-left citation-row"><h1 id=citation>Citation</h1><p>If you plan to use any part of the the MuSHR platform (including tutorials, codebase, or hardware instructions) for a project or paper, please cite
<em><a href=https://arxiv.org/abs/1908.08031>MuSHR: A Low-Cost, Open-Source Robotic Racecar for Education and Research</a></em>.</p><div class=highlight><pre class=chroma>@article{srinivasa2019mushr,
 title={{MuSHR}: A Low-Cost, Open-Source Robotic Racecar for Education and Research},
 author={Srinivasa, Siddhartha S. and Lancaster, Patrick and Michalove, Johan and Schmittle, Matt and Summers, Colin and Rockett, Matthew and Smith, Joshua R. and Chouhury, Sanjiban and Mavrogiannis, Christoforos and Sadeghi, Fereshteh},
 journal={CoRR},
 volume={abs/1908.08031},
 year={2019}
}
</pre></div><br></div></div></div></div><div class=footer><div class=container><div class=row><div class=col-12><div class=footer-inner><h3 class=footer-title>MuSHR: The UW Open Racecar Project</h3><ul><li class=menu-item-forum><a href=https://github.com/prl-mushr/mushr/discussions>Community Forum</a></li><li class=menu-item-contact><a href=/contact/>Contact</a></li><li class=menu-item-home><a href=/>Home</a></li></ul></div></div></div></div></div><div class=sub-footer><div class=container><div class=row><div class=col-12><div class=sub-footer-inner><ul></ul><ul><li class=prl>Made with <font color=#FF1690>â™¥</font> at the <a href=https://personalrobotics.cs.washington.edu/>Personal Robotics Lab</a></li></ul><ul><li class=prl>Website by <a href=https://micha.love/><font color=#36CDC4>Johan</font></a></li></ul></div></div></div></div></div><script type=text/javascript src=/js/scripts.min.8504133605a277da18f0d58cfd2e90d154962f4a961543a6e2f0a459a2d05462.js></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-146151202-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-146151202-1")</script></body></html>